---
title: "Getting Started with fabricatr: Advanced Features"
author: "Aaron Rudkin"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with Fabricatr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE}
library(fabricatr)
```

# More complicated level creation with variable numbers of observations

`level` can be used to create more complicated patterns of nesting. For example, when creating lower level data, it is possible to use a different `N` for each of the values of the higher level data:

```{r}
variable_data <-
  fabricate(
    cities = level(N = 2, elevation = runif(n = N, min = 1000, max = 2000)),
    citizens = level(N = c(2, 4), age = runif(N, 18, 70))
  )
variable_data
```

Here, each city has a different number of citizens. And the value of `N` used to create the age variable automatically updates as needed. The result is a dataset with 6 citizens, 2 in the first city and 4 in the second. As long as N is either a number, or a vector of the same length of the current lowest level of the data, `level` will know what to do.

It is also possible to provide a function to N, enabling a *random* number of citizens per city:

```{r}
my_data <-
  fabricate(
    cities = level(N = 2, elevation = runif(n = N, min = 1000, max = 2000)),
    citizens = level(N = sample(1:6, size = 2, replace = TRUE), 
                     age = runif(N, 18, 70))
  )
my_data
```

Here, each city is given a random number of citizens between 1 and 6. Since the `sample` function returns a vector of length 2, this is like specifying 2 separate `N`s as in the example above.

Finally, it is possible to define `N` on the basis of higher level variables themselves. Consider the following example:

```{r}
variable_n_function = fabricate(
  cities = level(N = 5, population = runif(N, 10, 200)),
  citizens = level(N = round(population * 0.3))
)
head(variable_n_function)
```

Here, the city has a defined population, and the number of citizens in our simulated data reflects a sample of 30% of that population. Each city has a different population, so each city gets a different number of citizens in this example.

# Averages within higher levels of hierarchy

You may want to include the mean value of a variable within a group defined by a higher level of the hierarchy, for example the average income of citizens within city. You can do this with `ave`:

```{r}
fabricate(
    cities = level(N = 2),
    citizens = level(N = 1:2, 
                     income = rnorm(N), 
                     income_mean_city = ave(income, cities))
    ) 
```

# Tidyverse integration

Because the functions in `fabricatr` take data and return data, they are easily slotted into a `tidyverse` workflow:

```{r, message=FALSE}
library(dplyr)

# letting higher levels depend on lower levels

my_data <- 
fabricate(
    cities = level(N = 2, elevation = runif(n = N, min = 1000, max = 2000)),
    citizens = level(N = c(2, 3), age = runif(N, 18, 70))
  ) %>%
  group_by(cities) %>%
  mutate(pop = n())

my_data

my_data <- 
data_frame(Y = sample(1:10, 2)) %>%
  fabricate(lower_level = level(N = 3, Y2 = Y + rnorm(N)))
my_data
```
