---
title: "Advanced features"
author: "Aaron Rudkin"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Advanced features}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE}
options(digits=2)
set.seed(19861108)
library(fabricatr)
```

# More complicated level creation with variable numbers of observations

[`add_level()`](../reference/add_level.html) can be used to create more complicated patterns of nesting. For example, when creating lower level data, it is possible to use a different `N` for each of the values of the higher level data:

```{r echo=TRUE, results="hide"}
variable_data <-
  fabricate(
    cities = add_level(N = 2, elevation = runif(n = N, min = 1000, max = 2000)),
    citizens = add_level(N = c(2, 4), age = runif(N, 18, 70))
  )
variable_data
```
```{r echo=FALSE}
knitr::kable(variable_data)
```

Here, each city has a different number of citizens. And the value of `N` used to create the age variable automatically updates as needed. The result is a dataset with 6 citizens, 2 in the first city and 4 in the second. As long as N is either a number, or a vector of the same length of the current lowest level of the data, [`add_level()`](../reference/add_level.html) will know what to do.

It is also possible to provide a function to N, enabling a *random* number of citizens per city:

```{r echo=TRUE, results="hide"}
my_data <-
  fabricate(
    cities = add_level(N = 2, elevation = runif(n = N, min = 1000, max = 2000)),
    citizens = add_level(N = sample(1:6, size = 2, replace = TRUE), 
                         age = runif(N, 18, 70))
  )
my_data
```
```{r echo=FALSE}
knitr::kable(my_data)
```

Here, each city is given a random number of citizens between 1 and 6. Since the `sample()` function returns a vector of length 2, this is like specifying 2 separate `N`s as in the example above.

Finally, it is possible to define `N` on the basis of higher level variables themselves. Consider the following example:

```{r echo=TRUE, results="hide"}
variable_n_function = fabricate(
  cities = add_level(N = 5, population = runif(N, 10, 200)),
  citizens = add_level(N = round(population * 0.3))
)
head(variable_n_function)
```
```{r echo=FALSE}
knitr::kable(head(variable_n_function))
```

Here, the city has a defined population, and the number of citizens in our simulated data reflects a sample of 30% of that population. Each city has a different population, so each city gets a different number of citizens in this example.

# Averages within higher levels of hierarchy

You may want to include the mean value of a variable within a group defined by a higher level of the hierarchy, for example the average income of citizens within city. You can do this with `ave()`:

```{r echo=TRUE, results="hide"}
ave_example = fabricate(
    cities = add_level(N = 2),
    citizens = add_level(N = 1:2, 
                         income = rnorm(N), 
                         income_mean_city = ave(income, cities))
    ) 
ave_example
```
```{r echo=FALSE}
knitr::kable(ave_example)
```

# Tidyverse integration

Because the functions in **fabricatr** take data and return data, they are cross-compatible with a `tidyverse` workflow:

```{r, message=FALSE, echo=TRUE, results="hide"}
library(dplyr)

# letting higher levels depend on lower levels

my_data <- 
fabricate(
    cities = add_level(N = 2, elevation = runif(n = N, min = 1000, max = 2000)),
    citizens = add_level(N = c(2, 3), age = runif(N, 18, 70))
  ) %>%
  group_by(cities) %>%
  mutate(pop = n())

my_data
```
```{r echo=FALSE}
knitr::kable(my_data)
```

```{r echo=TRUE, results="hide"}
my_data <- 
data_frame(Y = sample(1:10, 2)) %>% 
  fabricate(lower_level = add_level(N = 3, Y2 = Y + rnorm(N)))
my_data
```
```{r echo=FALSE}
knitr::kable(my_data)
```
