---
title: "Getting Started with Fabricatr"
author: "Graeme Blair, Jasper Cooper, Alexander Coppock, Macartan Humphreys"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
toc: true
vignette: >
  %\VignetteIndexEntry{Getting Started with Fabricatr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

`fabricatr` is a package designed to help you imagine your data before you collect it. While many solutions exist for creating simulated datasets, `fabricatr` is specifically designed to make the creation of realistic social science datasets easy. In particular, we need to be able to imagine **correlated** data and **hierarchical** data.


`fabricatr` is a member of the `DeclareDesign` software suite that includes the `r` packages [randomizr](randomizr.declaredesign.org), [estimatr](estimatr.declaredesign.org), and [Declare Design](declaredesign.org). `fabricatr` plays well with the [tidyverse](https://www.tidyverse.org/). 


# Basics

The workhorse function is `fabricate`. You provide a number to `N`, then a series of named functions. A nice feature is that you can use `N` as an argument to any of the functions you supply. Later functions can depend on values defined earlier, making the creation of correlated data easy

```{r}
library(fabricatr)
my_data <- fabricate(N = 5, Y = runif(N), Y2 = Y*5)
my_data
```

# Hierarchical data

We can create hierarchical data through use of the `level` function. In the example below, we create 2 cities, each with an elevation. We then create 3 citizens per city, each with an income.

There are three things to notice about this example:

1. The meaning of `N` changes.  In the `cities` line, `N` means 2, the number of cities.  In the `citizens` line, `N` means 3, the number of citizens.
2. The data created at the cities level is **constant** within cities. Each city has its own elevation. The data created at the citizens level is **not** constant within cities.
3. Variables created at a lower level can depend on variables created at a higher level. Citizen's income depends on the elevation of cities.

```{r}
my_data <-
  fabricate(
    cities = add_level(N = 2, elevation = runif(n = N, min = 1000, max = 2000)),
    citizens = nest_level(N = 3, income = round(elevation * rnorm(n = N, mean = 5)))
  )
my_data
```

# Fabricating variables

You can use any R function to fabricate a variable. For example, if you want to fabricate a random normal variable, you can use the base `R` function `rnorm()`, i.e.:

```{r}
fabricate(N = 3, normal_var = rnorm(N))
```

Now, what if you want to fabricate discrete variables like binary variables or counts?

## Binary can be called as binary, bernoulli, or binomial

```{r}
fabricate(N = 3, p = c(0, .5, 1), 
          binary = draw_discrete(p))
```


##  Binary can be called as binary, bernoulli, or binomial
```{r}
fabricate(N = 3, p = c(0, .5, 1), 
          binary = draw_discrete(p, type = "bernoulli"))
```

## Binary with link
```{r}
fabricate(N = 3, x = 10*rnorm(N), 
          binary = draw_discrete(x, type = "bernoulli", link = "probit"))
```

##  Binomial

```{r}
fabricate(N = 3, p = c(0, .5, 1), 
          binomial = draw_discrete(p, type = "binomial", k = 10))
```

## Binomial with link

```{r}
fabricate(N = 3, x = 10*rnorm(N), 
          binomial = draw_discrete(x, type = "binomial", k = 10, link = "logit"))
```

##  Ordered requires cutoffs

```{r}
set.seed(1)
fabricate(N = 3, x = 5*rnorm(N), 
          ordered = draw_discrete(x, type = "ordered", breaks = c(-Inf, -1, 1, Inf)))
```

This really just cuts the data

## Ordered probit
```{r}
set.seed(1)
fabricate(N = 3, x = 5*rnorm(N), 
          ordered = draw_discrete(x, type = "ordered", breaks = c(-Inf, -1, 1, Inf), link = "probit"))
```
This is actually ordered probit since x is normal.

## Count is poisson
```{r}
fabricate(N = 3, x = c(0,5,100), 
          count = draw_discrete(x, type = "count"))
```

Negative binomial easily added. Currently takes lamda as argument though could easily take a real number or a probability.

## Categorical  takes as input a matrix of probabilities (that get normalized if they do not sum to 1)
```{r}
fabricate(N = 6, 
          p1 = runif(N), 
          p2 = runif(N), 
          p3 = runif(N),
          cat = draw_discrete(cbind(p1, p2, p3), type = "categorical"))
```

This could also be set up to take latent variables in the style of multinomial probit or multinomial logit.


# Bringing in your own data

An essential part of imagining your data before you collect it is the ability to build on the data you all ready have.   

A second way you may wish to use existing data is bootstrap a new dataset from it, thereby preserving all the natural inter-correlations.

## Modifying existing data

If you have already conducted a baseline survey, you may which to imagine how the endline may deviate from it. In this case, you will want to add new variables to your existing dataset. Notice that the meaning of `N` in the definition of `Y_post` automatically refers to the number of rows in the dataset provided to the `data` argument.

```{r}
baseline_survey <- fabricate(N = 5, Y_pre = rnorm(N))

my_endline <- fabricate(data = baseline_survey, 
                             Y_post = Y_pre + rnorm(N))
my_endline
```

## Bootstrapping

Suppose you wanted to bootstrap from your baseline survey.

```{r}
bootstrapped_data <- resample_data(baseline_survey, N = 10)
bootstrapped_data
```

The real utility of this function comes when resampling from hierarchical data.  The example below takes a dataset that contains 2 cities, each with 3 citizens, then resamples to 3 cities, each with 5 citizens.

```{r}
my_data <-
  fabricate(
    cities = add_level(N = 2, elevation = runif(n = N, min = 1000, max = 2000)),
    citizens = nest_level(N = 3, income = round(elevation * rnorm(n = N, mean = 5)))
  )

my_data_2 <- resample_data(my_data, N = c(3, 5), ID_labels = c("cities", "citizens"))
my_data_2

```

When resampling, level names can also be specified in an alternative manner:

```{r}
my_data_2 <- resample_data(my_data, N = c(cities=3, citizens=5))
my_data_2
```

This example also resamples our dataset of 2 cities with 3 citizens to a dataset of 3 cities (each original city may be used zero or more times in the new sample) each with 5 citizens.

When resampling across multiple levels, it may be useful to transparently pass through all units of a particular level. For example, considering data with a clustered design, it may be useful to resample some number of individual observations from each original cluster.

```{r}
clustered_survey <- fabricate(
  clusters = add_level(N=25),
  cities = nest_level(N=10, population=runif(n = N, min=50000, max=1000000))
)

cluster_resample <- resample_data(clustered_survey, N = c(clusters=ALL, cities=5))
cluster_resample
```

This example begins with a dataset of 25 clusters each containing 10 cities and resamples to a dataset of the same 25 clusters, each containing 5 cities (the original cities may each be used zero or more times in the resampling process).

# Advanced Features

## Averages within higher levels of hierarchy

You may want to include the mean value of a variable within a group defined by a higher level of the hierarchy, for example the average income of citizens within city. You can do this with `ave`:

```{r}
fabricate(
    cities = add_level(N = 2),
    citizens = nest_level(
      N = 1:2, income = rnorm(N), income_mean_city = ave(income, cities))
  ) 
```

## Ns that vary

When making hierarchical data, you may not want to have the same number of units at each level of the hierarchy. For example, in the example below, we want one city to have 2 citizens and the other city to have four:

```{r}
my_data <-
  fabricate(
    cities = add_level(N = 2, elevation = runif(n = N, min = 1000, max = 2000)),
    citizens = nest_level(N = c(2, 4), income = round(elevation * rnorm(n = N, mean = 5)))
  )
my_data
```

You can even have Ns that are determined by a function, enabling a *random* number of citizens per city:

```{r}
my_data <-
  fabricate(
    cities = add_level(N = 2, elevation = runif(n = N, min = 1000, max = 2000)),
    citizens = nest_level(N = sample(1:6, size = 2, replace = TRUE), income = round(elevation * rnorm(n = N, mean = 5)))
  )
my_data
```


## Bringing in your own hierarchical data

Suppose you had existing hierarchical data, and you wanted to add variables that respected the levels.

```{r}

my_baseline_data <-
  fabricate(
    cities = add_level(N = 2, elevation = runif(n = N, min = 1000, max = 2000)),
    citizens = nest_level(N = 3, income = round(elevation * rnorm(n = N, mean = 5)))
  )

# add new variables at each level
my_data <- 
  fabricate(data = my_baseline_data,
                 cities = modify_level(density = elevation / 2),
                 citizens = modify_level(wealth = income - 100))

my_data

```

# Tidyverse integration

Because the functions in `fabricatr` take data and return data, they are easily slotted into a `tidyverse` workflow:

```{r, message=FALSE}
library(dplyr)

# letting higher levels depend on lower levels

my_data <- 
fabricate(
    cities = add_level(N = 2, elevation = runif(n = N, min = 1000, max = 2000)),
    citizens = nest_level(N = c(2, 3), income = round(elevation * rnorm(n = N, mean = 5)))
  ) %>%
  group_by(cities) %>%
  mutate(pop = n())

my_data

my_data <- 
data_frame(Y = sample(1:10, 2)) %>%
  fabricate(lower_level = nest_level(N = 3, Y2 = Y + rnorm(N)))
my_data
```
