#' Draw discrete variables including binary, binomial count, poisson count,
#' ordered, and categorical
#'
#' Drawing discrete data based on probabilities or latent traits is a common
#' task that can be cumbersome. Each function in our discrete drawing set creates
#' a different type of discrete data: `draw_binary` creates binary 0/1 data,
#' `draw_binomial` creates binomial data (repeated trial binary data),
#' `draw_categorical` creates categorical data, `draw_ordered` transforms latent
#' data into observed ordered categories, `draw_count` creates count data
#' (poisson-distributed)
#'
#' @param probs A number or vector of numbers representing the probability for
#' binary or binomial outcomes; or a number, vector, or matrix of numbers
#' representing probabilities for categorical outcomes. If you supply a link
#' function, these underlying probabilities will be transformed.
#' @param trials for `draw_binomial`, the number of trials for each observation
#' @param means for `draw_count`, the mean number of count units for each observation
#' @param x for `draw_ordered`, the latent data for each observation.
#' @param breaks vector of breaks to cut a latent outcome into ordered categories
#' @param break_labels vector of labels for the breaks to cut a latent outcome
#' into ordered categories.
#' @param N number of units to draw. Defaults to the length of the vector of
#' probabilities or latent data you provided
#' @param link link function between the latent variable and the probability of
#' a postiive outcome, i.e. "logit", "probit", or "identity". For the "identity"
#' link, the latent variable must be a probability.
#'
#' @examples
#' fabricate(N = 3,
#'    p = c(0, .5, 1),
#'    binary = draw_binary(probs = p))
#'
#'
#' fabricate(N = 3,
#'    x = 10 * rnorm(N),
#'    binary = draw_binary(probs = x, link = "probit"))
#'
#' fabricate(N = 3,
#'    p = c(0, .5, 1),
#'    binomial = draw_binomial(probs = p, trials = 10))
#'
#' fabricate(N = 3,
#'    x = 5 * rnorm(N),
#'    ordered = draw_ordered(x=x,
#'                           breaks = c(-Inf, -1, 1, Inf)))
#'
#' fabricate(N = 3,
#'    x = c(0,5,100),
#'    count = draw_count(means=x))
#'
#' # Categorical
#' fabricate(N = 6, p1 = runif(N), p2 = runif(N), p3 = runif(N),
#'           cat = draw_categorical(cbind(p1, p2, p3)))
#'
#' @importFrom stats pnorm rnorm rpois rbinom
#'
#' @export
#'
draw_binomial <- function(probs, trials=1, N = length(probs), link = "identity") {
  # Error handle probabilities and apply link function.
  if(mode(probs) != "numeric") {
    stop("Probabilities provided must be numeric.")
  }

  if (link == "identity") {
    if (!all(0 <= probs & probs <= 1)) {
      stop("The identity link requires probability values between 0 and 1,",
           "inclusive.")
    }
    if (N %% length(probs)) {
      stop(
        "\"N\" is not an even multiple of the length of the number of
        probabilities, \"probs\"."
      )
    }
  } else if (link == "logit") {
    probs <- 1 / (1 + exp(-probs))
  } else if (link == "probit") {
    probs <- pnorm(probs)
  } else {
    stop("Only 'identity', 'logit', 'and 'probit' are valid link functions.")
  }

  # Error handle trials
  if(is.vector(trials) & length(trials)>1) {
    if(N %% length(trials)) {
      stop(
        "\"N\" is not an even multiple of the length of the number of
        trials, \"trials\"."
      )
    }
    if(!all(is.numeric(trials) & (is.integer(trials) | !trials%%1))) {
      stop(
        "All numbers of trials should be integer numbers."
      )
    }
  }
  if(!is.null(dim(trials))) {
    stop(
      "Number of trials must be an integer or vector,",
      " not higher-dimensional."
    )
  }
  if(is.null(trials) | is.na(trials)) {
    stop(
      "Number of trials must be specified, not null or NA."
    )
  }
  if(is.numeric(trials) & !is.integer(trials) & trials%%1) {
    stop(
      "Number of trials must be an integer."
    )
  }
  if(any(trials <= 0)) {
    stop(
      "Number of trials must be a positive integer."
    )
  }

  return(rbinom(N, trials, probs))
}

#' @rdname draw_binomial
#' @export
draw_categorical <- function(probs, N=NULL, link = "identity") {
  if (link != "identity") {
    stop("Categorical data does not accept link functions.")
  }

  if (is.null(dim(probs))) {
    if (is.vector(probs) & all(is.numeric(probs)) & length(probs)>1) {
      if(is.null(N)) {
        stop("If probs is a vector of category probabilities, you must provide",
             " an explicit N argument.")
      }
      probs <- matrix(rep(probs, N), byrow=TRUE, ncol=length(probs), nrow=N)
      warning(
        "For a categorical (multinomial) distribution, a matrix of ",
        "probabilities should be provided. Data generated by interpreting ",
        "vector of category probabilities, identical for each observation."
      )
    } else {
      stop(
        "For a categorical (multinomial) distribution, a matrix of ",
        "probabilities should be provided"
      )
    }
  }
  if (!all(apply(probs, 1, min) > 0)) {
    stop(
      "For a categorical (multinomial) distribution, the elements of probs ",
      "should be positive and sum to a positive number."
    )
  }

  if(is.null(N)) {
    N = nrow(probs)
  }

  if(!(nrow(probs) %in% c(1, N))) {
    stop("The number of probability rows provided should be N or 1.")
  }

  m <- ncol(probs)
  rcateg <- function(p)
    sample(1:m, 1, prob = p)

  return(apply(probs, 1, rcateg))
}

#' @rdname draw_binomial
#' @export
draw_ordered <- function(x, breaks = c(-1, 0, 1), break_labels = NULL,
                         N = length(x), link = "identity") {
  # Link function
  if (link == "probit") {
    x <- x + rnorm(N)
  } else if (link != "identity") {
    stop("`draw_ordered` only accepts 'identity' and 'probit' link functions.")
  }

  # Error handling breaks
  if (is.null(breaks) | any(is.na(breaks))) {
    stop("You must specify numeric breaks for ordered data.")
  }
  if (any(!is.numeric(breaks))) {
    stop("All breaks specified for ordered data must be numeric.")
  }
  if (is.matrix(breaks) | is.data.frame(breaks)) {
    stop("Numeric breaks must be a vector.")
  }
  if (is.unsorted(breaks)) {
    stop("Numeric breaks must be in ascending order.")
  }

  # Check N/x
  if(N %% length(x)) {
    stop("N must be an even multiple of the length of x.")
  }

  # Pre-pend -Inf
  if(any(breaks[1] > x)) {
    breaks = c(-Inf, breaks)
  }
  # Post-pend Inf
  if(any(breaks[length(breaks)] < x)) {
    breaks = c(breaks, Inf)
  }

  # Make sure break labels are concordant with breaks.
  if(!is.null(break_labels) &&
     (is.vector(break_labels) &
      !is.logical(break_labels) &
      all(!is.na(break_labels)) &
      length(break_labels) != length(breaks)-1)) {
    stop("Break labels should be of length one less than breaks. ",
         "Currently you have ", length(break_labels), " bucket labels and ",
         length(breaks)-1, " buckets of data.")
  }

  # Output
  if(!is.null(break_labels)) {
    return(break_labels[findInterval(x, breaks)])
  } else {
    return(findInterval(x, breaks))
  }
}

#' @rdname draw_binomial
#' @export
draw_count <- function(means, N = length(means), link = "identity") {
  if (link != "identity") {
    stop("Count data does not accept link functions.")
  }

  if (any(means < 0)) {
    stop(
      "All provided count values must be non-negative."
    )
  }

  if(N %% length(means)) {
    stop("N must be an even multiple of the length of means.")
  }

  return(rpois(N, lambda = means))
}

#' @rdname draw_binomial
#' @export
draw_binary <- function(probs, N = length(probs), link = "identity") {
  return(draw_binomial(
    probs,
    N = N,
    link = link,
    trials = 1
  ))
}


# Stuff to circle back around to.
